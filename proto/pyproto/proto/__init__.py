# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: common_http.proto, creator_profile.proto, friend.proto, geo.proto, group.proto, health.proto, model.proto, place.proto, post.proto, prompt.proto, thought.proto, thread.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class HealthCheckResponseServingStatus(betterproto.Enum):
    UNKNOWN = 0
    SERVING = 1
    NOT_SERVING = 2
    SERVICE_UNKNOWN = 3


class ModelType(betterproto.Enum):
    GENERAL = 0
    PERSONAL = 1
    DELIBERATE = 2
    PROTOGEN = 3
    OPENJOURNEY = 4
    PORTRAITPLUS = 5
    DREAMSHAPER = 6
    EIMISANIME = 7


class GenerationSteps(betterproto.Enum):
    STEPS_NORMAL = 0
    STEPS_EXTENDED = 1


class GenerationQuality(betterproto.Enum):
    QUALITY_LOW = 0
    QUALITY_MEDIUM = 1
    QUALITY_HIGH = 2


class AspectRatio(betterproto.Enum):
    """1:1, 4:5, 9:16, 4:3, 5:3"""

    RATIO_1_1 = 0
    RATIO_4_5 = 1
    RATIO_9_16 = 2
    RATIO_4_3 = 3
    RATIO_5_3 = 4


class GuidanceScale(betterproto.Enum):
    SCALE_LOW = 0
    SCALE_MEDIUM = 1
    SCALE_HIGH = 2


class ControlType(betterproto.Enum):
    NONE = 0
    POSE = 1


class RealmPostType(betterproto.Enum):
    DAILY = 0
    CUSTOM = 1
    REFIT = 2
    FEATURED = 3


class ModelState(betterproto.Enum):
    INITIAL = 0
    TRAINING = 1
    TRAINED = 2
    FAILED = 3
    UNKNOWN = 4


@dataclass(eq=False, repr=False)
class RequestWithoutPage(betterproto.Message):
    """common Request proto"""

    id_token: str = betterproto.string_field(1)
    custom_token: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ResponseWithoutPage(betterproto.Message):
    """common Response proto"""

    err_code: str = betterproto.string_field(1)
    err_msg: str = betterproto.string_field(2)
    data: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class CreatorProfile(betterproto.Message):
    creator_uid: Optional[str] = betterproto.string_field(
        1, optional=True, group="_creatorUid"
    )
    name: Optional[str] = betterproto.string_field(2, optional=True, group="_name")
    bio: Optional[str] = betterproto.string_field(3, optional=True, group="_bio")
    photo_url: Optional[str] = betterproto.string_field(
        4, optional=True, group="_photoUrl"
    )
    is_private: Optional[bool] = betterproto.bool_field(
        5, optional=True, group="_isPrivate"
    )
    karma: Optional[float] = betterproto.float_field(6, optional=True, group="_karma")
    in_waiting_list: Optional[bool] = betterproto.bool_field(
        7, optional=True, group="_inWaitingList"
    )
    max_invite: Optional[int] = betterproto.int64_field(
        8, optional=True, group="_maxInvite"
    )
    used_invite: Optional[int] = betterproto.int64_field(
        9, optional=True, group="_usedInvite"
    )
    username: Optional[str] = betterproto.string_field(
        10, optional=True, group="_username"
    )
    is_npc: Optional[bool] = betterproto.bool_field(11, optional=True, group="_isNPC")
    is_deleted: Optional[bool] = betterproto.bool_field(
        12, optional=True, group="_isDeleted"
    )
    tags: List[str] = betterproto.string_field(13)
    huddle_karma: Optional[float] = betterproto.float_field(
        14, optional=True, group="_huddleKarma"
    )
    subscription_tier: Optional[str] = betterproto.string_field(
        15, optional=True, group="_subscriptionTier"
    )
    subscription_expiration_date: Optional[str] = betterproto.string_field(
        16, optional=True, group="_subscriptionExpirationDate"
    )
    subscription_credits: Optional[int] = betterproto.int64_field(
        17, optional=True, group="_subscriptionCredits"
    )
    subscription_training_credits: Optional[int] = betterproto.int64_field(
        18, optional=True, group="_subscriptionTrainingCredits"
    )
    is_featured: Optional[bool] = betterproto.bool_field(
        19, optional=True, group="_isFeatured"
    )
    model_privacy: Optional[str] = betterproto.string_field(
        20, optional=True, group="_modelPrivacy"
    )
    realm_credits: Optional[int] = betterproto.int64_field(
        21, optional=True, group="_realmCredits"
    )


@dataclass(eq=False, repr=False)
class CreatorProfiles(betterproto.Message):
    profiles: List["CreatorProfile"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Friend(betterproto.Message):
    uid: str = betterproto.string_field(1)
    """The uid of the pending/accepted friend"""

    is_initiator: bool = betterproto.bool_field(2)
    """Is the target user the initiator of the friend request"""

    is_accepted: bool = betterproto.bool_field(3)
    """Is the target user the initiator of the friend request"""

    app_ids: List[str] = betterproto.string_field(4)
    """App Identifier"""

    timestamp: datetime = betterproto.message_field(5)
    """The timestamp of last interaction"""


@dataclass(eq=False, repr=False)
class Geo(betterproto.Message):
    """Geographic address of a location. Next Tag: 5"""

    latitude: float = betterproto.double_field(1)
    longitude: float = betterproto.double_field(2)
    altitude: float = betterproto.double_field(3)
    redius_in_meters: float = betterproto.double_field(4)


@dataclass(eq=False, repr=False)
class Groups(betterproto.Message):
    groups: List["Group"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Group(betterproto.Message):
    name: str = betterproto.string_field(1)
    """The unique name that identifies the group."""

    description: Optional[str] = betterproto.string_field(
        2, optional=True, group="_description"
    )
    """The unique id that identifies the thought."""

    creator_uid: Optional[str] = betterproto.string_field(
        3, optional=True, group="_creatorUid"
    )
    """The original author uid that starts the group."""

    tags: List[str] = betterproto.string_field(4)
    """Tags of the group, editable by author only"""

    num_followers: Optional[int] = betterproto.int64_field(
        5, optional=True, group="_numFollowers"
    )
    """Number of followers"""

    num_likes: Optional[int] = betterproto.int64_field(
        6, optional=True, group="_numLikes"
    )
    """Number of likes"""

    num_threads: Optional[int] = betterproto.int64_field(
        7, optional=True, group="_numThreads"
    )
    """Number of threads"""

    place_latitude: Optional[float] = betterproto.double_field(
        8, optional=True, group="_placeLatitude"
    )
    """Karma score of the place"""

    place_longitude: Optional[float] = betterproto.double_field(
        9, optional=True, group="_placeLongitude"
    )
    """Karma score of the place"""

    google_place_id: Optional[str] = betterproto.string_field(
        10, optional=True, group="_googlePlaceID"
    )
    """A place name tag to the place"""

    display_name: Optional[str] = betterproto.string_field(
        11, optional=True, group="_displayName"
    )
    """The display name, which has less restrictions than the group name"""

    is_private: Optional[bool] = betterproto.bool_field(
        12, optional=True, group="_isPrivate"
    )
    """Private Group"""


@dataclass(eq=False, repr=False)
class HealthCheckRequest(betterproto.Message):
    service: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class HealthCheckResponse(betterproto.Message):
    status: "HealthCheckResponseServingStatus" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class ThreadVideo(betterproto.Message):
    creation_time: datetime = betterproto.message_field(1)
    creator_uid: str = betterproto.string_field(2)
    share_id: str = betterproto.string_field(3)
    thought_id: str = betterproto.string_field(4)
    like_count: Optional[int] = betterproto.int64_field(
        11, optional=True, group="_likeCount"
    )
    remix_count: Optional[int] = betterproto.int64_field(
        12, optional=True, group="_remixCount"
    )
    share_count: Optional[int] = betterproto.int64_field(
        13, optional=True, group="_shareCount"
    )
    parent_share_id: Optional[str] = betterproto.string_field(
        14, optional=True, group="_parentShareId"
    )
    thread_id: Optional[str] = betterproto.string_field(
        15, optional=True, group="_threadId"
    )
    media_ready: Optional[bool] = betterproto.bool_field(
        16, optional=True, group="_mediaReady"
    )
    hd_ready: Optional[bool] = betterproto.bool_field(
        17, optional=True, group="_HDReady"
    )
    sd_ready: Optional[bool] = betterproto.bool_field(
        18, optional=True, group="_SDReady"
    )
    app_id: Optional[str] = betterproto.string_field(19, optional=True, group="_appId")


@dataclass(eq=False, repr=False)
class Thread(betterproto.Message):
    creators: List[str] = betterproto.string_field(1)
    """All creators to this thread."""

    last_update_time: datetime = betterproto.message_field(2)
    """The last time when one new video is added to the thread."""

    orig_share_id: str = betterproto.string_field(3)
    """The original video id that starts the thread."""

    orig_uid: str = betterproto.string_field(4)
    """The original author uid that starts the thread."""

    start_time: datetime = betterproto.message_field(5)
    """The start time of the thread."""

    thread_id: str = betterproto.string_field(6)
    """The unique id that identifies the thread."""

    title: Optional[str] = betterproto.string_field(11, optional=True, group="_title")
    """Title of the thread, editable by author only"""

    descriptions: Optional[str] = betterproto.string_field(
        17, optional=True, group="_descriptions"
    )
    """Descriptions of the thread, editable by author only"""

    hashtags: Optional[str] = betterproto.string_field(
        21, optional=True, group="_hashtags"
    )
    """Descriptions of the thread, editable by author only"""

    color: Optional[str] = betterproto.string_field(24, optional=True, group="_color")
    """Descriptions of the thread, editable by author only"""

    total_like_count: Optional[int] = betterproto.int64_field(
        12, optional=True, group="_totalLikeCount"
    )
    """Total likes count from all thread videos"""

    total_share_count: Optional[int] = betterproto.int64_field(
        13, optional=True, group="_totalShareCount"
    )
    """Total shares count from all thread videos"""

    total_remix_count: Optional[int] = betterproto.int64_field(
        14, optional=True, group="_totalRemixCount"
    )
    """Total remix count from all thread videos"""

    state: Optional[str] = betterproto.string_field(16, optional=True, group="_state")
    """Thread state. Currently supported state: deleting"""

    place_name: Optional[str] = betterproto.string_field(
        18, optional=True, group="_placeName"
    )
    """A place name tag to the thread"""

    place_id: Optional[str] = betterproto.string_field(
        20, optional=True, group="_placeID"
    )
    """A place id to the thread, based on google map definition"""

    place_coordinate: Optional["Coordinate2D"] = betterproto.message_field(
        19, optional=True, group="_placeCoordinate"
    )
    """A place coordinate tag to the thread [retired]"""

    feed_score: Optional[float] = betterproto.double_field(
        22, optional=True, group="_feedScore"
    )
    """A score representing priority in feed"""

    app_id: Optional[str] = betterproto.string_field(23, optional=True, group="_appId")
    """App bundle identifier"""

    group_name: Optional[str] = betterproto.string_field(
        25, optional=True, group="_groupName"
    )
    """A group (community) name"""

    language: Optional[str] = betterproto.string_field(
        26, optional=True, group="_language"
    )
    """The language preference of the thread"""

    album_video_path: Optional[str] = betterproto.string_field(
        27, optional=True, group="_albumVideoPath"
    )
    """The album video which showcase the highlights of the thread"""

    album_video_thumbnail_path: Optional[str] = betterproto.string_field(
        28, optional=True, group="_albumVideoThumbnailPath"
    )
    """The album video thumbnail"""

    place_latitude: Optional[float] = betterproto.double_field(
        29, optional=True, group="_placeLatitude"
    )
    """The place latitude"""

    place_longitude: Optional[float] = betterproto.double_field(
        30, optional=True, group="_placeLongitude"
    )
    """The place longitude"""

    highlight_share_id: Optional[str] = betterproto.string_field(
        31, optional=True, group="_highlightShareId"
    )
    """The share id of hightlight video in feed, if any"""

    commenters: List[str] = betterproto.string_field(32)
    """The list of commenter uids"""

    likers: List[str] = betterproto.string_field(33)
    """The list of uids who liked the thread"""

    tags: List[str] = betterproto.string_field(34)
    """The user inputted tags"""


@dataclass(eq=False, repr=False)
class ThreadAndVideoTuple(betterproto.Message):
    thread: "Thread" = betterproto.message_field(1)
    thread_video: "ThreadVideo" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ResponseFeed(betterproto.Message):
    err_code: str = betterproto.string_field(1)
    err_msg: str = betterproto.string_field(2)
    data: List["ThreadAndVideoTuple"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ResponseNewestThreads(betterproto.Message):
    err_code: str = betterproto.string_field(1)
    err_msg: str = betterproto.string_field(2)
    datas: List["ThreadVideo"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Coordinate2D(betterproto.Message):
    latitude: float = betterproto.double_field(1)
    longitude: float = betterproto.double_field(2)


@dataclass(eq=False, repr=False)
class RequestFeed(betterproto.Message):
    uid: Optional[str] = betterproto.string_field(1, optional=True, group="_uid")
    coordinate: Optional["Coordinate2D"] = betterproto.message_field(
        2, optional=True, group="_coordinate"
    )
    app_id: Optional[str] = betterproto.string_field(3, optional=True, group="_appID")
    request_id: Optional[str] = betterproto.string_field(
        4, optional=True, group="_requestID"
    )
    language: Optional[str] = betterproto.string_field(
        5, optional=True, group="_language"
    )
    group_name: Optional[str] = betterproto.string_field(
        6, optional=True, group="_groupName"
    )
    is_new_user: Optional[bool] = betterproto.bool_field(
        7, optional=True, group="_isNewUser"
    )
    friend_only: Optional[bool] = betterproto.bool_field(
        8, optional=True, group="_friendOnly"
    )
    with_mixer: Optional[bool] = betterproto.bool_field(
        9, optional=True, group="_withMixer"
    )
    with_watch_state: Optional[bool] = betterproto.bool_field(
        10, optional=True, group="_withWatchState"
    )
    promote_followed_groups: Optional[bool] = betterproto.bool_field(
        11, optional=True, group="_promoteFollowedGroups"
    )
    self_only: Optional[bool] = betterproto.bool_field(
        12, optional=True, group="_selfOnly"
    )
    custom_only: Optional[bool] = betterproto.bool_field(
        13, optional=True, group="_customOnly"
    )
    refit_only: Optional[bool] = betterproto.bool_field(
        14, optional=True, group="_refitOnly"
    )
    daily_only: Optional[bool] = betterproto.bool_field(
        15, optional=True, group="_dailyOnly"
    )


@dataclass(eq=False, repr=False)
class PromptRequest(betterproto.Message):
    uid: Optional[str] = betterproto.string_field(1, optional=True, group="_uid")
    app_id: Optional[str] = betterproto.string_field(2, optional=True, group="_appID")
    request_id: Optional[str] = betterproto.string_field(
        3, optional=True, group="_requestID"
    )
    prompt_positive: Optional[str] = betterproto.string_field(
        4, optional=True, group="_promptPositive"
    )
    prompt_negative: Optional[str] = betterproto.string_field(
        5, optional=True, group="_promptNegative"
    )
    allow_nsfw: Optional[bool] = betterproto.bool_field(
        6, optional=True, group="_allowNsfw"
    )
    timestamp: Optional[datetime] = betterproto.message_field(
        7, optional=True, group="_timestamp"
    )
    type: Optional[str] = betterproto.string_field(8, optional=True, group="_type")
    notification_id: Optional[str] = betterproto.string_field(
        9, optional=True, group="_notificationID"
    )
    model_type: Optional["ModelType"] = betterproto.enum_field(
        10, optional=True, group="_modelType"
    )
    generation_steps: Optional["GenerationSteps"] = betterproto.enum_field(
        11, optional=True, group="_generationSteps"
    )
    generation_quality: Optional["GenerationQuality"] = betterproto.enum_field(
        12, optional=True, group="_generationQuality"
    )
    aspect_ratio: Optional["AspectRatio"] = betterproto.enum_field(
        13, optional=True, group="_aspectRatio"
    )
    guidance_scale: Optional["GuidanceScale"] = betterproto.enum_field(
        14, optional=True, group="_guidanceScale"
    )
    start_image: Optional[str] = betterproto.string_field(
        15, optional=True, group="_startImage"
    )
    control_strength: Optional[int] = betterproto.int64_field(
        16, optional=True, group="_controlStrength"
    )
    hits_to_skip: Optional[int] = betterproto.int64_field(
        17, optional=True, group="_hitsToSkip"
    )
    mask_image: Optional[str] = betterproto.string_field(
        18, optional=True, group="_maskImage"
    )
    backend_release_version: Optional[str] = betterproto.string_field(
        19, optional=True, group="_backendReleaseVersion"
    )
    app_version: Optional[str] = betterproto.string_field(
        20, optional=True, group="_appVersion"
    )
    control_type: Optional["ControlType"] = betterproto.enum_field(
        21, optional=True, group="_controlType"
    )
    control_source: Optional[str] = betterproto.string_field(
        22, optional=True, group="_controlSource"
    )


@dataclass(eq=False, repr=False)
class Prompt(betterproto.Message):
    name: Optional[str] = betterproto.string_field(1, optional=True, group="_name")
    description: Optional[str] = betterproto.string_field(
        2, optional=True, group="_description"
    )
    date: Optional[int] = betterproto.int64_field(3, optional=True, group="_date")
    seed: Optional[int] = betterproto.int64_field(4, optional=True, group="_seed")
    prompt_positive: Optional[str] = betterproto.string_field(
        5, optional=True, group="_promptPositive"
    )
    prompt_negative: Optional[str] = betterproto.string_field(
        6, optional=True, group="_promptNegative"
    )
    sample_image_path: List[str] = betterproto.string_field(7)
    is_example: Optional[bool] = betterproto.bool_field(
        8, optional=True, group="_isExample"
    )
    model_type: Optional["ModelType"] = betterproto.enum_field(
        10, optional=True, group="_modelType"
    )
    generation_steps: Optional["GenerationSteps"] = betterproto.enum_field(
        11, optional=True, group="_generationSteps"
    )
    generation_quality: Optional["GenerationQuality"] = betterproto.enum_field(
        12, optional=True, group="_generationQuality"
    )
    aspect_ratio: Optional["AspectRatio"] = betterproto.enum_field(
        13, optional=True, group="_aspectRatio"
    )
    guidance_scale: Optional["GuidanceScale"] = betterproto.enum_field(
        14, optional=True, group="_guidanceScale"
    )
    start_image: Optional[str] = betterproto.string_field(
        15, optional=True, group="_startImage"
    )
    control_strength: Optional[int] = betterproto.int64_field(
        16, optional=True, group="_controlStrength"
    )
    generation_count: Optional[int] = betterproto.int64_field(
        17, optional=True, group="_generationCount"
    )
    tags: List[str] = betterproto.string_field(18)
    mask_image: Optional[str] = betterproto.string_field(
        19, optional=True, group="_maskImage"
    )
    modifier_strength: Optional[float] = betterproto.float_field(
        20, optional=True, group="_modifierStrength"
    )
    control_type: Optional["ControlType"] = betterproto.enum_field(
        21, optional=True, group="_controlType"
    )
    control_source: Optional[str] = betterproto.string_field(
        22, optional=True, group="_controlSource"
    )
    hidden: Optional[bool] = betterproto.bool_field(23, optional=True, group="_hidden")
    timestamp: Optional[float] = betterproto.double_field(
        24, optional=True, group="_timestamp"
    )
    uid: Optional[str] = betterproto.string_field(25, optional=True, group="_uid")
    post_type: Optional["RealmPostType"] = betterproto.enum_field(
        26, optional=True, group="_postType"
    )
    thread_id: Optional[str] = betterproto.string_field(
        27, optional=True, group="_threadID"
    )
    prompt_id: Optional[str] = betterproto.string_field(
        28, optional=True, group="_promptID"
    )
    enforced_prompt_negative: Optional[str] = betterproto.string_field(
        29, optional=True, group="_enforcedPromptNegative"
    )


@dataclass(eq=False, repr=False)
class Prompts(betterproto.Message):
    prompts: List["Prompt"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Features(betterproto.Message):
    features: List[float] = betterproto.float_field(1)


@dataclass(eq=False, repr=False)
class Model(betterproto.Message):
    uid: Optional[str] = betterproto.string_field(1, optional=True, group="_uid")
    description: Optional[str] = betterproto.string_field(
        2, optional=True, group="_description"
    )
    version: Optional[float] = betterproto.double_field(
        3, optional=True, group="_version"
    )
    model_type: Optional["ModelType"] = betterproto.enum_field(
        4, optional=True, group="_modelType"
    )
    model_state: Optional["ModelState"] = betterproto.enum_field(
        5, optional=True, group="_modelState"
    )
    storage_path: Optional[str] = betterproto.string_field(
        6, optional=True, group="_storagePath"
    )
    prompt_negative: Optional[str] = betterproto.string_field(
        7, optional=True, group="_promptNegative"
    )
    training_score: Optional[float] = betterproto.double_field(
        8, optional=True, group="_trainingScore"
    )
    inference_score: Optional[float] = betterproto.double_field(
        9, optional=True, group="_inferenceScore"
    )
    commit_hash: Optional[str] = betterproto.string_field(
        10, optional=True, group="_commitHash"
    )
    predicted_token: Optional[str] = betterproto.string_field(
        11, optional=True, group="_predictedToken"
    )


@dataclass(eq=False, repr=False)
class Places(betterproto.Message):
    places: List["Place"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Place(betterproto.Message):
    place_id: str = betterproto.string_field(1)
    """The unique id that identifies the place."""

    start_time: Optional[datetime] = betterproto.message_field(
        2, optional=True, group="_startTime"
    )
    """The start time of the place."""

    orig_uid: Optional[str] = betterproto.string_field(
        3, optional=True, group="_origUid"
    )
    """The original author uid that starts the place."""

    descriptions: Optional[str] = betterproto.string_field(
        4, optional=True, group="_descriptions"
    )
    """Descriptions of the place, editable by author only"""

    hashtags: List[str] = betterproto.string_field(5)
    """Descriptions of the place, editable by author only"""

    state: Optional[str] = betterproto.string_field(6, optional=True, group="_state")
    """Place state. Currently supported state: timeless, deleting"""

    place_name: Optional[str] = betterproto.string_field(
        7, optional=True, group="_placeName"
    )
    """A place name tag to the place"""

    place_latitude: Optional[float] = betterproto.double_field(
        8, optional=True, group="_placeLatitude"
    )
    """Karma score of the place"""

    place_longitude: Optional[float] = betterproto.double_field(
        9, optional=True, group="_placeLongitude"
    )
    """Karma score of the place"""

    google_place_id: Optional[str] = betterproto.string_field(
        10, optional=True, group="_googlePlaceID"
    )
    """A place name tag to the place"""

    app_id: Optional[str] = betterproto.string_field(11, optional=True, group="_appID")
    """App bundle identifier"""

    karma: Optional[float] = betterproto.double_field(12, optional=True, group="_karma")
    """Karma score of the place"""

    follower_count: Optional[int] = betterproto.int64_field(
        13, optional=True, group="_followerCount"
    )
    """The number of total followers of the place"""

    post_count: Optional[int] = betterproto.int64_field(
        14, optional=True, group="_postCount"
    )
    """The number of total posts of the place"""

    feed_score: Optional[float] = betterproto.double_field(
        15, optional=True, group="_feedScore"
    )
    """A score representing priority in feed"""


@dataclass(eq=False, repr=False)
class Posts(betterproto.Message):
    posts: List["Post"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Post(betterproto.Message):
    post_id: str = betterproto.string_field(1)
    """The unique id that identifies the post."""

    thought_id: List[str] = betterproto.string_field(2)
    """The unique id that identifies the thought."""

    group_id: Optional[str] = betterproto.string_field(
        3, optional=True, group="_groupID"
    )
    """The unique id that identifies the group that post belongs to."""

    timestamp: Optional[datetime] = betterproto.message_field(
        4, optional=True, group="_timestamp"
    )
    """The start time of the post."""

    uid: Optional[str] = betterproto.string_field(5, optional=True, group="_uid")
    """The original author uid that starts the post."""

    state: Optional[str] = betterproto.string_field(6, optional=True, group="_state")
    """Post state. Currently supported state: timeless, deleting"""

    language: Optional[str] = betterproto.string_field(
        7, optional=True, group="_language"
    )
    """The language preference of the post"""

    title: Optional[str] = betterproto.string_field(8, optional=True, group="_title")
    """Title of the post, editable by author only"""

    descriptions: Optional[str] = betterproto.string_field(
        9, optional=True, group="_descriptions"
    )
    """Descriptions of the post, editable by author only"""

    hashtags: List[str] = betterproto.string_field(10)
    """Hashtags of the post, editable by author only"""

    color: Optional[str] = betterproto.string_field(11, optional=True, group="_color")
    """Color of the post, editable by author only"""

    total_like_count: Optional[int] = betterproto.int64_field(
        12, optional=True, group="_totalLikeCount"
    )
    """Total likes count"""

    total_share_count: Optional[int] = betterproto.int64_field(
        13, optional=True, group="_totalShareCount"
    )
    """Total shares count"""

    total_remix_count: Optional[int] = betterproto.int64_field(
        14, optional=True, group="_totalRemixCount"
    )
    """Total remix count"""

    app_id: Optional[str] = betterproto.string_field(15, optional=True, group="_appID")
    """App bundle identifier"""

    karma: Optional[float] = betterproto.double_field(16, optional=True, group="_karma")
    """Karma score of the post"""

    feed_score: Optional[float] = betterproto.double_field(
        17, optional=True, group="_feedScore"
    )
    """A score representing priority in feed"""


@dataclass(eq=False, repr=False)
class Thought(betterproto.Message):
    session_id: str = betterproto.string_field(1)
    creation_time: int = betterproto.int64_field(2)
    server_merged_media_path: str = betterproto.string_field(11)
    server_merged_media_size: int = betterproto.int64_field(12)
    server_exported_media_path: str = betterproto.string_field(13)
    server_exported_media_size: int = betterproto.int64_field(14)
    server_thumbnail_image_path: str = betterproto.string_field(15)
    server_thumbnail_size: int = betterproto.int64_field(16)
    server_hd_media_path: str = betterproto.string_field(17)
    server_hd_media_size: int = betterproto.int64_field(18)
    server_sd_media_path: str = betterproto.string_field(19)
    server_sd_media_size: int = betterproto.int64_field(20)


class HealthStub(betterproto.ServiceStub):
    async def check(
        self,
        health_check_request: "HealthCheckRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "HealthCheckResponse":
        return await self._unary_unary(
            "/proto.Health/Check",
            health_check_request,
            HealthCheckResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def watch(
        self,
        health_check_request: "HealthCheckRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["HealthCheckResponse"]:
        async for response in self._unary_stream(
            "/proto.Health/Watch",
            health_check_request,
            HealthCheckResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class PromptSearchStub(betterproto.ServiceStub):
    async def echo(
        self,
        prompt_request: "PromptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PromptRequest":
        return await self._unary_unary(
            "/proto.PromptSearch/Echo",
            prompt_request,
            PromptRequest,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_images_from_prompt(
        self,
        prompt_request: "PromptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Prompts":
        return await self._unary_unary(
            "/proto.PromptSearch/SearchImagesFromPrompt",
            prompt_request,
            Prompts,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_styles_from_prompt(
        self,
        prompt_request: "PromptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Prompts":
        return await self._unary_unary(
            "/proto.PromptSearch/SearchStylesFromPrompt",
            prompt_request,
            Prompts,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_users_from_text(
        self,
        prompt_request: "PromptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreatorProfiles":
        return await self._unary_unary(
            "/proto.PromptSearch/SearchUsersFromText",
            prompt_request,
            CreatorProfiles,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_prompt_history(
        self,
        prompt_request: "PromptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Prompts":
        return await self._unary_unary(
            "/proto.PromptSearch/SearchPromptHistory",
            prompt_request,
            Prompts,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def hide_prompt_from_user(
        self,
        prompt_request: "PromptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Prompt":
        return await self._unary_unary(
            "/proto.PromptSearch/HidePromptFromUser",
            prompt_request,
            Prompt,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_features_for_post(
        self,
        prompt_request: "PromptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Features":
        return await self._unary_unary(
            "/proto.PromptSearch/GetFeaturesForPost",
            prompt_request,
            Features,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_posts_from_prompt(
        self,
        prompt_request: "PromptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ResponseFeed":
        return await self._unary_unary(
            "/proto.PromptSearch/SearchPostsFromPrompt",
            prompt_request,
            ResponseFeed,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class HealthBase(ServiceBase):
    async def check(
        self, health_check_request: "HealthCheckRequest"
    ) -> "HealthCheckResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def watch(
        self, health_check_request: "HealthCheckRequest"
    ) -> AsyncIterator["HealthCheckResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_check(
        self, stream: "grpclib.server.Stream[HealthCheckRequest, HealthCheckResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.check(request)
        await stream.send_message(response)

    async def __rpc_watch(
        self, stream: "grpclib.server.Stream[HealthCheckRequest, HealthCheckResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.watch,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/proto.Health/Check": grpclib.const.Handler(
                self.__rpc_check,
                grpclib.const.Cardinality.UNARY_UNARY,
                HealthCheckRequest,
                HealthCheckResponse,
            ),
            "/proto.Health/Watch": grpclib.const.Handler(
                self.__rpc_watch,
                grpclib.const.Cardinality.UNARY_STREAM,
                HealthCheckRequest,
                HealthCheckResponse,
            ),
        }


class PromptSearchBase(ServiceBase):
    async def echo(self, prompt_request: "PromptRequest") -> "PromptRequest":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_images_from_prompt(
        self, prompt_request: "PromptRequest"
    ) -> "Prompts":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_styles_from_prompt(
        self, prompt_request: "PromptRequest"
    ) -> "Prompts":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_users_from_text(
        self, prompt_request: "PromptRequest"
    ) -> "CreatorProfiles":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_prompt_history(self, prompt_request: "PromptRequest") -> "Prompts":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def hide_prompt_from_user(self, prompt_request: "PromptRequest") -> "Prompt":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_features_for_post(
        self, prompt_request: "PromptRequest"
    ) -> "Features":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_posts_from_prompt(
        self, prompt_request: "PromptRequest"
    ) -> "ResponseFeed":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_echo(
        self, stream: "grpclib.server.Stream[PromptRequest, PromptRequest]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.echo(request)
        await stream.send_message(response)

    async def __rpc_search_images_from_prompt(
        self, stream: "grpclib.server.Stream[PromptRequest, Prompts]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_images_from_prompt(request)
        await stream.send_message(response)

    async def __rpc_search_styles_from_prompt(
        self, stream: "grpclib.server.Stream[PromptRequest, Prompts]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_styles_from_prompt(request)
        await stream.send_message(response)

    async def __rpc_search_users_from_text(
        self, stream: "grpclib.server.Stream[PromptRequest, CreatorProfiles]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_users_from_text(request)
        await stream.send_message(response)

    async def __rpc_search_prompt_history(
        self, stream: "grpclib.server.Stream[PromptRequest, Prompts]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_prompt_history(request)
        await stream.send_message(response)

    async def __rpc_hide_prompt_from_user(
        self, stream: "grpclib.server.Stream[PromptRequest, Prompt]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.hide_prompt_from_user(request)
        await stream.send_message(response)

    async def __rpc_get_features_for_post(
        self, stream: "grpclib.server.Stream[PromptRequest, Features]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_features_for_post(request)
        await stream.send_message(response)

    async def __rpc_search_posts_from_prompt(
        self, stream: "grpclib.server.Stream[PromptRequest, ResponseFeed]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_posts_from_prompt(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/proto.PromptSearch/Echo": grpclib.const.Handler(
                self.__rpc_echo,
                grpclib.const.Cardinality.UNARY_UNARY,
                PromptRequest,
                PromptRequest,
            ),
            "/proto.PromptSearch/SearchImagesFromPrompt": grpclib.const.Handler(
                self.__rpc_search_images_from_prompt,
                grpclib.const.Cardinality.UNARY_UNARY,
                PromptRequest,
                Prompts,
            ),
            "/proto.PromptSearch/SearchStylesFromPrompt": grpclib.const.Handler(
                self.__rpc_search_styles_from_prompt,
                grpclib.const.Cardinality.UNARY_UNARY,
                PromptRequest,
                Prompts,
            ),
            "/proto.PromptSearch/SearchUsersFromText": grpclib.const.Handler(
                self.__rpc_search_users_from_text,
                grpclib.const.Cardinality.UNARY_UNARY,
                PromptRequest,
                CreatorProfiles,
            ),
            "/proto.PromptSearch/SearchPromptHistory": grpclib.const.Handler(
                self.__rpc_search_prompt_history,
                grpclib.const.Cardinality.UNARY_UNARY,
                PromptRequest,
                Prompts,
            ),
            "/proto.PromptSearch/HidePromptFromUser": grpclib.const.Handler(
                self.__rpc_hide_prompt_from_user,
                grpclib.const.Cardinality.UNARY_UNARY,
                PromptRequest,
                Prompt,
            ),
            "/proto.PromptSearch/GetFeaturesForPost": grpclib.const.Handler(
                self.__rpc_get_features_for_post,
                grpclib.const.Cardinality.UNARY_UNARY,
                PromptRequest,
                Features,
            ),
            "/proto.PromptSearch/SearchPostsFromPrompt": grpclib.const.Handler(
                self.__rpc_search_posts_from_prompt,
                grpclib.const.Cardinality.UNARY_UNARY,
                PromptRequest,
                ResponseFeed,
            ),
        }
